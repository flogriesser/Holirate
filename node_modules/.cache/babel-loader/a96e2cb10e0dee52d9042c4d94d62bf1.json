{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { BaseNode, interval } from 'kapellmeister';\nimport mergeKeys from '../core/mergeKeys';\nimport { ENTER, UPDATE, LEAVE } from '../core/types';\nimport { numeric } from '../utils';\n\nvar NodeGroup = function (_Component) {\n  _inherits(NodeGroup, _Component);\n\n  var _super = _createSuper(NodeGroup);\n\n  function NodeGroup(props) {\n    var _this;\n\n    _classCallCheck(this, NodeGroup);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"animate\", function () {\n      var _this$state = _this.state,\n          nodeKeys = _this$state.nodeKeys,\n          nodeHash = _this$state.nodeHash;\n\n      if (_this.unmounting) {\n        return;\n      }\n\n      var pending = false;\n      var nextNodeKeys = [];\n      var length = nodeKeys.length;\n\n      for (var i = 0; i < length; i++) {\n        var k = nodeKeys[i];\n        var n = nodeHash[k];\n        var isTransitioning = n.isTransitioning();\n\n        if (isTransitioning) {\n          pending = true;\n        }\n\n        if (n.type === LEAVE && !isTransitioning) {\n          delete nodeHash[k];\n        } else {\n          nextNodeKeys.push(k);\n        }\n      }\n\n      if (!pending) {\n        _this.interval.stop();\n      }\n\n      _this.setState(function () {\n        return {\n          nodeKeys: nextNodeKeys,\n          nodes: nextNodeKeys.map(function (key) {\n            return nodeHash[key];\n          })\n        };\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"interval\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"unmounting\", false);\n\n    var interpolation = props.interpolation;\n\n    var Node = function (_BaseNode) {\n      _inherits(Node, _BaseNode);\n\n      var _super2 = _createSuper(Node);\n\n      function Node(key, data) {\n        var _this2;\n\n        _classCallCheck(this, Node);\n\n        _this2 = _super2.call(this);\n\n        _defineProperty(_assertThisInitialized(_this2), \"getInterpolator\", interpolation);\n\n        _this2.key = key;\n        _this2.data = data;\n        _this2.type = ENTER;\n        return _this2;\n      }\n\n      return Node;\n    }(BaseNode);\n\n    _this.state = {\n      Node: Node,\n      nodeKeys: [],\n      nodeHash: {},\n      nodes: [],\n      data: null\n    };\n    return _this;\n  }\n\n  _createClass(NodeGroup, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.startInterval();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.data !== this.props.data && !this.unmounting) {\n        this.startInterval();\n      }\n    }\n  }, {\n    key: \"startInterval\",\n    value: function startInterval() {\n      if (!this.interval) {\n        this.interval = interval(this.animate);\n      } else {\n        this.interval.restart(this.animate);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this$state2 = this.state,\n          nodeKeys = _this$state2.nodeKeys,\n          nodeHash = _this$state2.nodeHash;\n      this.unmounting = true;\n\n      if (this.interval) {\n        this.interval.stop();\n      }\n\n      nodeKeys.forEach(function (key) {\n        nodeHash[key].stopTransitions();\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var renderedChildren = this.props.children(this.state.nodes);\n      return renderedChildren && React.Children.only(renderedChildren);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.data !== prevState.data) {\n        var data = nextProps.data,\n            keyAccessor = nextProps.keyAccessor,\n            start = nextProps.start,\n            enter = nextProps.enter,\n            update = nextProps.update,\n            leave = nextProps.leave;\n        var Node = prevState.Node,\n            nodeKeys = prevState.nodeKeys,\n            nodeHash = prevState.nodeHash;\n        var keyIndex = {};\n\n        for (var i = 0; i < nodeKeys.length; i++) {\n          keyIndex[nodeKeys[i]] = i;\n        }\n\n        var nextKeyIndex = {};\n        var nextNodeKeys = [];\n\n        for (var _i = 0; _i < data.length; _i++) {\n          var d = data[_i];\n          var k = keyAccessor(d, _i);\n          nextKeyIndex[k] = _i;\n          nextNodeKeys.push(k);\n\n          if (keyIndex[k] === undefined) {\n            var node = new Node();\n            node.key = k;\n            node.data = d;\n            node.type = ENTER;\n            nodeHash[k] = node;\n          }\n        }\n\n        for (var _i2 = 0; _i2 < nodeKeys.length; _i2++) {\n          var _k = nodeKeys[_i2];\n          var n = nodeHash[_k];\n\n          if (nextKeyIndex[_k] !== undefined) {\n            n.data = data[nextKeyIndex[_k]];\n            n.type = UPDATE;\n          } else {\n            n.type = LEAVE;\n          }\n        }\n\n        var mergedNodeKeys = mergeKeys(nodeKeys, keyIndex, nextNodeKeys, nextKeyIndex);\n\n        for (var _i3 = 0; _i3 < mergedNodeKeys.length; _i3++) {\n          var _k2 = mergedNodeKeys[_i3];\n          var _n = nodeHash[_k2];\n          var _d = _n.data;\n\n          if (_n.type === ENTER) {\n            _n.setState(start(_d, nextKeyIndex[_k2]));\n\n            _n.transition(enter(_d, nextKeyIndex[_k2]));\n          } else if (_n.type === LEAVE) {\n            _n.transition(leave(_d, keyIndex[_k2]));\n          } else {\n            _n.transition(update(_d, nextKeyIndex[_k2]));\n          }\n        }\n\n        return {\n          data: data,\n          nodes: mergedNodeKeys.map(function (key) {\n            return nodeHash[key];\n          }),\n          nodeHash: nodeHash,\n          nodeKeys: mergedNodeKeys\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return NodeGroup;\n}(Component);\n\nNodeGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  data: PropTypes.array.isRequired,\n  keyAccessor: PropTypes.func.isRequired,\n  interpolation: PropTypes.func,\n  start: PropTypes.func.isRequired,\n  enter: PropTypes.func,\n  update: PropTypes.func,\n  leave: PropTypes.func,\n  children: PropTypes.func.isRequired\n} : {};\nNodeGroup.defaultProps = {\n  enter: function enter() {},\n  update: function update() {},\n  leave: function leave() {},\n  interpolation: numeric\n};\nexport default NodeGroup;","map":{"version":3,"sources":["/home/flo/Projects/react/Holirate/node_modules/react-move/es/NodeGroup/index.js"],"names":["_classCallCheck","_createClass","_assertThisInitialized","_inherits","_possibleConstructorReturn","_getPrototypeOf","_defineProperty","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","React","Component","PropTypes","BaseNode","interval","mergeKeys","ENTER","UPDATE","LEAVE","numeric","NodeGroup","_Component","_super","props","_this","_this$state","state","nodeKeys","nodeHash","unmounting","pending","nextNodeKeys","length","i","k","n","isTransitioning","type","push","stop","setState","nodes","map","key","interpolation","Node","_BaseNode","_super2","data","_this2","value","componentDidMount","startInterval","componentDidUpdate","prevProps","animate","restart","componentWillUnmount","_this$state2","forEach","stopTransitions","render","renderedChildren","children","Children","only","getDerivedStateFromProps","nextProps","prevState","keyAccessor","start","enter","update","leave","keyIndex","nextKeyIndex","_i","d","undefined","node","_i2","_k","mergedNodeKeys","_i3","_k2","_n","_d","transition","propTypes","process","env","NODE_ENV","array","isRequired","func","defaultProps"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;AACA,OAAOC,YAAP,MAAyB,wCAAzB;AACA,OAAOC,sBAAP,MAAmC,kDAAnC;AACA,OAAOC,SAAP,MAAsB,qCAAtB;AACA,OAAOC,0BAAP,MAAuC,sDAAvC;AACA,OAAOC,eAAP,MAA4B,2CAA5B;AACA,OAAOC,eAAP,MAA4B,2CAA5B;;AAEA,SAASC,YAAT,CAAsBC,OAAtB,EAA+B;AAAE,MAAIC,yBAAyB,GAAGC,yBAAyB,EAAzD;;AAA6D,SAAO,SAASC,oBAAT,GAAgC;AAAE,QAAIC,KAAK,GAAGP,eAAe,CAACG,OAAD,CAA3B;AAAA,QAAsCK,MAAtC;;AAA8C,QAAIJ,yBAAJ,EAA+B;AAAE,UAAIK,SAAS,GAAGT,eAAe,CAAC,IAAD,CAAf,CAAsBU,WAAtC;;AAAmDF,MAAAA,MAAM,GAAGG,OAAO,CAACC,SAAR,CAAkBL,KAAlB,EAAyBM,SAAzB,EAAoCJ,SAApC,CAAT;AAA0D,KAA9I,MAAoJ;AAAED,MAAAA,MAAM,GAAGD,KAAK,CAACO,KAAN,CAAY,IAAZ,EAAkBD,SAAlB,CAAT;AAAwC;;AAAC,WAAOd,0BAA0B,CAAC,IAAD,EAAOS,MAAP,CAAjC;AAAkD,GAAxU;AAA2U;;AAEza,SAASH,yBAAT,GAAqC;AAAE,MAAI,OAAOM,OAAP,KAAmB,WAAnB,IAAkC,CAACA,OAAO,CAACC,SAA/C,EAA0D,OAAO,KAAP;AAAc,MAAID,OAAO,CAACC,SAAR,CAAkBG,IAAtB,EAA4B,OAAO,KAAP;AAAc,MAAI,OAAOC,KAAP,KAAiB,UAArB,EAAiC,OAAO,IAAP;;AAAa,MAAI;AAAEC,IAAAA,OAAO,CAACC,SAAR,CAAkBC,OAAlB,CAA0BC,IAA1B,CAA+BT,OAAO,CAACC,SAAR,CAAkBK,OAAlB,EAA2B,EAA3B,EAA+B,YAAY,CAAE,CAA7C,CAA/B;AAAgF,WAAO,IAAP;AAAc,GAApG,CAAqG,OAAOI,CAAP,EAAU;AAAE,WAAO,KAAP;AAAe;AAAE;;AAEzU,OAAOC,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,SAASC,QAAT,EAAmBC,QAAnB,QAAmC,eAAnC;AACA,OAAOC,SAAP,MAAsB,mBAAtB;AACA,SAASC,KAAT,EAAgBC,MAAhB,EAAwBC,KAAxB,QAAqC,eAArC;AACA,SAASC,OAAT,QAAwB,UAAxB;;AAEA,IAAIC,SAAS,GAAG,UAAUC,UAAV,EAAsB;AACpCnC,EAAAA,SAAS,CAACkC,SAAD,EAAYC,UAAZ,CAAT;;AAEA,MAAIC,MAAM,GAAGhC,YAAY,CAAC8B,SAAD,CAAzB;;AAEA,WAASA,SAAT,CAAmBG,KAAnB,EAA0B;AACxB,QAAIC,KAAJ;;AAEAzC,IAAAA,eAAe,CAAC,IAAD,EAAOqC,SAAP,CAAf;;AAEAI,IAAAA,KAAK,GAAGF,MAAM,CAACd,IAAP,CAAY,IAAZ,EAAkBe,KAAlB,CAAR;;AAEAlC,IAAAA,eAAe,CAACJ,sBAAsB,CAACuC,KAAD,CAAvB,EAAgC,SAAhC,EAA2C,YAAY;AACpE,UAAIC,WAAW,GAAGD,KAAK,CAACE,KAAxB;AAAA,UACIC,QAAQ,GAAGF,WAAW,CAACE,QAD3B;AAAA,UAEIC,QAAQ,GAAGH,WAAW,CAACG,QAF3B;;AAIA,UAAIJ,KAAK,CAACK,UAAV,EAAsB;AACpB;AACD;;AAED,UAAIC,OAAO,GAAG,KAAd;AACA,UAAIC,YAAY,GAAG,EAAnB;AACA,UAAIC,MAAM,GAAGL,QAAQ,CAACK,MAAtB;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,MAApB,EAA4BC,CAAC,EAA7B,EAAiC;AAC/B,YAAIC,CAAC,GAAGP,QAAQ,CAACM,CAAD,CAAhB;AACA,YAAIE,CAAC,GAAGP,QAAQ,CAACM,CAAD,CAAhB;AACA,YAAIE,eAAe,GAAGD,CAAC,CAACC,eAAF,EAAtB;;AAEA,YAAIA,eAAJ,EAAqB;AACnBN,UAAAA,OAAO,GAAG,IAAV;AACD;;AAED,YAAIK,CAAC,CAACE,IAAF,KAAWnB,KAAX,IAAoB,CAACkB,eAAzB,EAA0C;AACxC,iBAAOR,QAAQ,CAACM,CAAD,CAAf;AACD,SAFD,MAEO;AACLH,UAAAA,YAAY,CAACO,IAAb,CAAkBJ,CAAlB;AACD;AACF;;AAED,UAAI,CAACJ,OAAL,EAAc;AACZN,QAAAA,KAAK,CAACV,QAAN,CAAeyB,IAAf;AACD;;AAEDf,MAAAA,KAAK,CAACgB,QAAN,CAAe,YAAY;AACzB,eAAO;AACLb,UAAAA,QAAQ,EAAEI,YADL;AAELU,UAAAA,KAAK,EAAEV,YAAY,CAACW,GAAb,CAAiB,UAAUC,GAAV,EAAe;AACrC,mBAAOf,QAAQ,CAACe,GAAD,CAAf;AACD,WAFM;AAFF,SAAP;AAMD,OAPD;AAQD,KAzCc,CAAf;;AA2CAtD,IAAAA,eAAe,CAACJ,sBAAsB,CAACuC,KAAD,CAAvB,EAAgC,UAAhC,EAA4C,IAA5C,CAAf;;AAEAnC,IAAAA,eAAe,CAACJ,sBAAsB,CAACuC,KAAD,CAAvB,EAAgC,YAAhC,EAA8C,KAA9C,CAAf;;AAEA,QAAIoB,aAAa,GAAGrB,KAAK,CAACqB,aAA1B;;AAEA,QAAIC,IAAI,GAAG,UAAUC,SAAV,EAAqB;AAC9B5D,MAAAA,SAAS,CAAC2D,IAAD,EAAOC,SAAP,CAAT;;AAEA,UAAIC,OAAO,GAAGzD,YAAY,CAACuD,IAAD,CAA1B;;AAEA,eAASA,IAAT,CAAcF,GAAd,EAAmBK,IAAnB,EAAyB;AACvB,YAAIC,MAAJ;;AAEAlE,QAAAA,eAAe,CAAC,IAAD,EAAO8D,IAAP,CAAf;;AAEAI,QAAAA,MAAM,GAAGF,OAAO,CAACvC,IAAR,CAAa,IAAb,CAAT;;AAEAnB,QAAAA,eAAe,CAACJ,sBAAsB,CAACgE,MAAD,CAAvB,EAAiC,iBAAjC,EAAoDL,aAApD,CAAf;;AAEAK,QAAAA,MAAM,CAACN,GAAP,GAAaA,GAAb;AACAM,QAAAA,MAAM,CAACD,IAAP,GAAcA,IAAd;AACAC,QAAAA,MAAM,CAACZ,IAAP,GAAcrB,KAAd;AACA,eAAOiC,MAAP;AACD;;AAED,aAAOJ,IAAP;AACD,KArBU,CAqBThC,QArBS,CAAX;;AAuBAW,IAAAA,KAAK,CAACE,KAAN,GAAc;AACZmB,MAAAA,IAAI,EAAEA,IADM;AAEZlB,MAAAA,QAAQ,EAAE,EAFE;AAGZC,MAAAA,QAAQ,EAAE,EAHE;AAIZa,MAAAA,KAAK,EAAE,EAJK;AAKZO,MAAAA,IAAI,EAAE;AALM,KAAd;AAOA,WAAOxB,KAAP;AACD;;AAEDxC,EAAAA,YAAY,CAACoC,SAAD,EAAY,CAAC;AACvBuB,IAAAA,GAAG,EAAE,mBADkB;AAEvBO,IAAAA,KAAK,EAAE,SAASC,iBAAT,GAA6B;AAClC,WAAKC,aAAL;AACD;AAJsB,GAAD,EAKrB;AACDT,IAAAA,GAAG,EAAE,oBADJ;AAEDO,IAAAA,KAAK,EAAE,SAASG,kBAAT,CAA4BC,SAA5B,EAAuC;AAC5C,UAAIA,SAAS,CAACN,IAAV,KAAmB,KAAKzB,KAAL,CAAWyB,IAA9B,IAAsC,CAAC,KAAKnB,UAAhD,EAA4D;AAC1D,aAAKuB,aAAL;AACD;AACF;AANA,GALqB,EAYrB;AACDT,IAAAA,GAAG,EAAE,eADJ;AAEDO,IAAAA,KAAK,EAAE,SAASE,aAAT,GAAyB;AAC9B,UAAI,CAAC,KAAKtC,QAAV,EAAoB;AAClB,aAAKA,QAAL,GAAgBA,QAAQ,CAAC,KAAKyC,OAAN,CAAxB;AACD,OAFD,MAEO;AACL,aAAKzC,QAAL,CAAc0C,OAAd,CAAsB,KAAKD,OAA3B;AACD;AACF;AARA,GAZqB,EAqBrB;AACDZ,IAAAA,GAAG,EAAE,sBADJ;AAEDO,IAAAA,KAAK,EAAE,SAASO,oBAAT,GAAgC;AACrC,UAAIC,YAAY,GAAG,KAAKhC,KAAxB;AAAA,UACIC,QAAQ,GAAG+B,YAAY,CAAC/B,QAD5B;AAAA,UAEIC,QAAQ,GAAG8B,YAAY,CAAC9B,QAF5B;AAGA,WAAKC,UAAL,GAAkB,IAAlB;;AAEA,UAAI,KAAKf,QAAT,EAAmB;AACjB,aAAKA,QAAL,CAAcyB,IAAd;AACD;;AAEDZ,MAAAA,QAAQ,CAACgC,OAAT,CAAiB,UAAUhB,GAAV,EAAe;AAC9Bf,QAAAA,QAAQ,CAACe,GAAD,CAAR,CAAciB,eAAd;AACD,OAFD;AAGD;AAfA,GArBqB,EAqCrB;AACDjB,IAAAA,GAAG,EAAE,QADJ;AAEDO,IAAAA,KAAK,EAAE,SAASW,MAAT,GAAkB;AACvB,UAAIC,gBAAgB,GAAG,KAAKvC,KAAL,CAAWwC,QAAX,CAAoB,KAAKrC,KAAL,CAAWe,KAA/B,CAAvB;AACA,aAAOqB,gBAAgB,IAAIpD,KAAK,CAACsD,QAAN,CAAeC,IAAf,CAAoBH,gBAApB,CAA3B;AACD;AALA,GArCqB,CAAZ,EA2CR,CAAC;AACHnB,IAAAA,GAAG,EAAE,0BADF;AAEHO,IAAAA,KAAK,EAAE,SAASgB,wBAAT,CAAkCC,SAAlC,EAA6CC,SAA7C,EAAwD;AAC7D,UAAID,SAAS,CAACnB,IAAV,KAAmBoB,SAAS,CAACpB,IAAjC,EAAuC;AACrC,YAAIA,IAAI,GAAGmB,SAAS,CAACnB,IAArB;AAAA,YACIqB,WAAW,GAAGF,SAAS,CAACE,WAD5B;AAAA,YAEIC,KAAK,GAAGH,SAAS,CAACG,KAFtB;AAAA,YAGIC,KAAK,GAAGJ,SAAS,CAACI,KAHtB;AAAA,YAIIC,MAAM,GAAGL,SAAS,CAACK,MAJvB;AAAA,YAKIC,KAAK,GAAGN,SAAS,CAACM,KALtB;AAMA,YAAI5B,IAAI,GAAGuB,SAAS,CAACvB,IAArB;AAAA,YACIlB,QAAQ,GAAGyC,SAAS,CAACzC,QADzB;AAAA,YAEIC,QAAQ,GAAGwC,SAAS,CAACxC,QAFzB;AAGA,YAAI8C,QAAQ,GAAG,EAAf;;AAEA,aAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,QAAQ,CAACK,MAA7B,EAAqCC,CAAC,EAAtC,EAA0C;AACxCyC,UAAAA,QAAQ,CAAC/C,QAAQ,CAACM,CAAD,CAAT,CAAR,GAAwBA,CAAxB;AACD;;AAED,YAAI0C,YAAY,GAAG,EAAnB;AACA,YAAI5C,YAAY,GAAG,EAAnB;;AAEA,aAAK,IAAI6C,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAG5B,IAAI,CAAChB,MAA3B,EAAmC4C,EAAE,EAArC,EAAyC;AACvC,cAAIC,CAAC,GAAG7B,IAAI,CAAC4B,EAAD,CAAZ;AACA,cAAI1C,CAAC,GAAGmC,WAAW,CAACQ,CAAD,EAAID,EAAJ,CAAnB;AACAD,UAAAA,YAAY,CAACzC,CAAD,CAAZ,GAAkB0C,EAAlB;AACA7C,UAAAA,YAAY,CAACO,IAAb,CAAkBJ,CAAlB;;AAEA,cAAIwC,QAAQ,CAACxC,CAAD,CAAR,KAAgB4C,SAApB,EAA+B;AAC7B,gBAAIC,IAAI,GAAG,IAAIlC,IAAJ,EAAX;AACAkC,YAAAA,IAAI,CAACpC,GAAL,GAAWT,CAAX;AACA6C,YAAAA,IAAI,CAAC/B,IAAL,GAAY6B,CAAZ;AACAE,YAAAA,IAAI,CAAC1C,IAAL,GAAYrB,KAAZ;AACAY,YAAAA,QAAQ,CAACM,CAAD,CAAR,GAAc6C,IAAd;AACD;AACF;;AAED,aAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGrD,QAAQ,CAACK,MAAjC,EAAyCgD,GAAG,EAA5C,EAAgD;AAC9C,cAAIC,EAAE,GAAGtD,QAAQ,CAACqD,GAAD,CAAjB;AACA,cAAI7C,CAAC,GAAGP,QAAQ,CAACqD,EAAD,CAAhB;;AAEA,cAAIN,YAAY,CAACM,EAAD,CAAZ,KAAqBH,SAAzB,EAAoC;AAClC3C,YAAAA,CAAC,CAACa,IAAF,GAASA,IAAI,CAAC2B,YAAY,CAACM,EAAD,CAAb,CAAb;AACA9C,YAAAA,CAAC,CAACE,IAAF,GAASpB,MAAT;AACD,WAHD,MAGO;AACLkB,YAAAA,CAAC,CAACE,IAAF,GAASnB,KAAT;AACD;AACF;;AAED,YAAIgE,cAAc,GAAGnE,SAAS,CAACY,QAAD,EAAW+C,QAAX,EAAqB3C,YAArB,EAAmC4C,YAAnC,CAA9B;;AAEA,aAAK,IAAIQ,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGD,cAAc,CAAClD,MAAvC,EAA+CmD,GAAG,EAAlD,EAAsD;AACpD,cAAIC,GAAG,GAAGF,cAAc,CAACC,GAAD,CAAxB;AACA,cAAIE,EAAE,GAAGzD,QAAQ,CAACwD,GAAD,CAAjB;AACA,cAAIE,EAAE,GAAGD,EAAE,CAACrC,IAAZ;;AAEA,cAAIqC,EAAE,CAAChD,IAAH,KAAYrB,KAAhB,EAAuB;AACrBqE,YAAAA,EAAE,CAAC7C,QAAH,CAAY8B,KAAK,CAACgB,EAAD,EAAKX,YAAY,CAACS,GAAD,CAAjB,CAAjB;;AAEAC,YAAAA,EAAE,CAACE,UAAH,CAAchB,KAAK,CAACe,EAAD,EAAKX,YAAY,CAACS,GAAD,CAAjB,CAAnB;AACD,WAJD,MAIO,IAAIC,EAAE,CAAChD,IAAH,KAAYnB,KAAhB,EAAuB;AAC5BmE,YAAAA,EAAE,CAACE,UAAH,CAAcd,KAAK,CAACa,EAAD,EAAKZ,QAAQ,CAACU,GAAD,CAAb,CAAnB;AACD,WAFM,MAEA;AACLC,YAAAA,EAAE,CAACE,UAAH,CAAcf,MAAM,CAACc,EAAD,EAAKX,YAAY,CAACS,GAAD,CAAjB,CAApB;AACD;AACF;;AAED,eAAO;AACLpC,UAAAA,IAAI,EAAEA,IADD;AAELP,UAAAA,KAAK,EAAEyC,cAAc,CAACxC,GAAf,CAAmB,UAAUC,GAAV,EAAe;AACvC,mBAAOf,QAAQ,CAACe,GAAD,CAAf;AACD,WAFM,CAFF;AAKLf,UAAAA,QAAQ,EAAEA,QALL;AAMLD,UAAAA,QAAQ,EAAEuD;AANL,SAAP;AAQD;;AAED,aAAO,IAAP;AACD;AA9EE,GAAD,CA3CQ,CAAZ;;AA4HA,SAAO9D,SAAP;AACD,CA3Ne,CA2NdT,SA3Nc,CAAhB;;AA6NAS,SAAS,CAACoE,SAAV,GAAsBC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC;AAC5D3C,EAAAA,IAAI,EAAEpC,SAAS,CAACgF,KAAV,CAAgBC,UADsC;AAE5DxB,EAAAA,WAAW,EAAEzD,SAAS,CAACkF,IAAV,CAAeD,UAFgC;AAG5DjD,EAAAA,aAAa,EAAEhC,SAAS,CAACkF,IAHmC;AAI5DxB,EAAAA,KAAK,EAAE1D,SAAS,CAACkF,IAAV,CAAeD,UAJsC;AAK5DtB,EAAAA,KAAK,EAAE3D,SAAS,CAACkF,IAL2C;AAM5DtB,EAAAA,MAAM,EAAE5D,SAAS,CAACkF,IAN0C;AAO5DrB,EAAAA,KAAK,EAAE7D,SAAS,CAACkF,IAP2C;AAQ5D/B,EAAAA,QAAQ,EAAEnD,SAAS,CAACkF,IAAV,CAAeD;AARmC,CAAxC,GASlB,EATJ;AAUAzE,SAAS,CAAC2E,YAAV,GAAyB;AACvBxB,EAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB,CAAE,CADH;AAEvBC,EAAAA,MAAM,EAAE,SAASA,MAAT,GAAkB,CAAE,CAFL;AAGvBC,EAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB,CAAE,CAHH;AAIvB7B,EAAAA,aAAa,EAAEzB;AAJQ,CAAzB;AAMA,eAAeC,SAAf","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { BaseNode, interval } from 'kapellmeister';\nimport mergeKeys from '../core/mergeKeys';\nimport { ENTER, UPDATE, LEAVE } from '../core/types';\nimport { numeric } from '../utils';\n\nvar NodeGroup = function (_Component) {\n  _inherits(NodeGroup, _Component);\n\n  var _super = _createSuper(NodeGroup);\n\n  function NodeGroup(props) {\n    var _this;\n\n    _classCallCheck(this, NodeGroup);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"animate\", function () {\n      var _this$state = _this.state,\n          nodeKeys = _this$state.nodeKeys,\n          nodeHash = _this$state.nodeHash;\n\n      if (_this.unmounting) {\n        return;\n      }\n\n      var pending = false;\n      var nextNodeKeys = [];\n      var length = nodeKeys.length;\n\n      for (var i = 0; i < length; i++) {\n        var k = nodeKeys[i];\n        var n = nodeHash[k];\n        var isTransitioning = n.isTransitioning();\n\n        if (isTransitioning) {\n          pending = true;\n        }\n\n        if (n.type === LEAVE && !isTransitioning) {\n          delete nodeHash[k];\n        } else {\n          nextNodeKeys.push(k);\n        }\n      }\n\n      if (!pending) {\n        _this.interval.stop();\n      }\n\n      _this.setState(function () {\n        return {\n          nodeKeys: nextNodeKeys,\n          nodes: nextNodeKeys.map(function (key) {\n            return nodeHash[key];\n          })\n        };\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"interval\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"unmounting\", false);\n\n    var interpolation = props.interpolation;\n\n    var Node = function (_BaseNode) {\n      _inherits(Node, _BaseNode);\n\n      var _super2 = _createSuper(Node);\n\n      function Node(key, data) {\n        var _this2;\n\n        _classCallCheck(this, Node);\n\n        _this2 = _super2.call(this);\n\n        _defineProperty(_assertThisInitialized(_this2), \"getInterpolator\", interpolation);\n\n        _this2.key = key;\n        _this2.data = data;\n        _this2.type = ENTER;\n        return _this2;\n      }\n\n      return Node;\n    }(BaseNode);\n\n    _this.state = {\n      Node: Node,\n      nodeKeys: [],\n      nodeHash: {},\n      nodes: [],\n      data: null\n    };\n    return _this;\n  }\n\n  _createClass(NodeGroup, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.startInterval();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.data !== this.props.data && !this.unmounting) {\n        this.startInterval();\n      }\n    }\n  }, {\n    key: \"startInterval\",\n    value: function startInterval() {\n      if (!this.interval) {\n        this.interval = interval(this.animate);\n      } else {\n        this.interval.restart(this.animate);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var _this$state2 = this.state,\n          nodeKeys = _this$state2.nodeKeys,\n          nodeHash = _this$state2.nodeHash;\n      this.unmounting = true;\n\n      if (this.interval) {\n        this.interval.stop();\n      }\n\n      nodeKeys.forEach(function (key) {\n        nodeHash[key].stopTransitions();\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var renderedChildren = this.props.children(this.state.nodes);\n      return renderedChildren && React.Children.only(renderedChildren);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.data !== prevState.data) {\n        var data = nextProps.data,\n            keyAccessor = nextProps.keyAccessor,\n            start = nextProps.start,\n            enter = nextProps.enter,\n            update = nextProps.update,\n            leave = nextProps.leave;\n        var Node = prevState.Node,\n            nodeKeys = prevState.nodeKeys,\n            nodeHash = prevState.nodeHash;\n        var keyIndex = {};\n\n        for (var i = 0; i < nodeKeys.length; i++) {\n          keyIndex[nodeKeys[i]] = i;\n        }\n\n        var nextKeyIndex = {};\n        var nextNodeKeys = [];\n\n        for (var _i = 0; _i < data.length; _i++) {\n          var d = data[_i];\n          var k = keyAccessor(d, _i);\n          nextKeyIndex[k] = _i;\n          nextNodeKeys.push(k);\n\n          if (keyIndex[k] === undefined) {\n            var node = new Node();\n            node.key = k;\n            node.data = d;\n            node.type = ENTER;\n            nodeHash[k] = node;\n          }\n        }\n\n        for (var _i2 = 0; _i2 < nodeKeys.length; _i2++) {\n          var _k = nodeKeys[_i2];\n          var n = nodeHash[_k];\n\n          if (nextKeyIndex[_k] !== undefined) {\n            n.data = data[nextKeyIndex[_k]];\n            n.type = UPDATE;\n          } else {\n            n.type = LEAVE;\n          }\n        }\n\n        var mergedNodeKeys = mergeKeys(nodeKeys, keyIndex, nextNodeKeys, nextKeyIndex);\n\n        for (var _i3 = 0; _i3 < mergedNodeKeys.length; _i3++) {\n          var _k2 = mergedNodeKeys[_i3];\n          var _n = nodeHash[_k2];\n          var _d = _n.data;\n\n          if (_n.type === ENTER) {\n            _n.setState(start(_d, nextKeyIndex[_k2]));\n\n            _n.transition(enter(_d, nextKeyIndex[_k2]));\n          } else if (_n.type === LEAVE) {\n            _n.transition(leave(_d, keyIndex[_k2]));\n          } else {\n            _n.transition(update(_d, nextKeyIndex[_k2]));\n          }\n        }\n\n        return {\n          data: data,\n          nodes: mergedNodeKeys.map(function (key) {\n            return nodeHash[key];\n          }),\n          nodeHash: nodeHash,\n          nodeKeys: mergedNodeKeys\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return NodeGroup;\n}(Component);\n\nNodeGroup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  data: PropTypes.array.isRequired,\n  keyAccessor: PropTypes.func.isRequired,\n  interpolation: PropTypes.func,\n  start: PropTypes.func.isRequired,\n  enter: PropTypes.func,\n  update: PropTypes.func,\n  leave: PropTypes.func,\n  children: PropTypes.func.isRequired\n} : {};\nNodeGroup.defaultProps = {\n  enter: function enter() {},\n  update: function update() {},\n  leave: function leave() {},\n  interpolation: numeric\n};\nexport default NodeGroup;"]},"metadata":{},"sourceType":"module"}