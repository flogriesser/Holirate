"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.defaultAxiosInstance = exports.X_GOOG_MAPS_EXPERIENCE_ID = exports.acceptEncoding = exports.userAgent = exports.defaultTimeout = exports.defaultHttpsAgent = void 0;
const rax = require("retry-axios");
const directions_1 = require("./directions");
const distance_1 = require("./distance");
const elevation_1 = require("./elevation");
const findplacefromtext_1 = require("./places/findplacefromtext");
const geocode_1 = require("./geocode/geocode");
const geolocate_1 = require("./geolocate");
const nearestroads_1 = require("./roads/nearestroads");
const autocomplete_1 = require("./places/autocomplete");
const details_1 = require("./places/details");
const photo_1 = require("./places/photo");
const queryautocomplete_1 = require("./places/queryautocomplete");
const placesnearby_1 = require("./places/placesnearby");
const reversegeocode_1 = require("./geocode/reversegeocode");
const snaptoroads_1 = require("./roads/snaptoroads");
const textsearch_1 = require("./places/textsearch");
const timezone_1 = require("./timezone");
const axios_1 = require("axios");
const agentkeepalive_1 = require("agentkeepalive");
const index_1 = require("./index");
const adapter_1 = require("./adapter");
exports.defaultHttpsAgent = new agentkeepalive_1.HttpsAgent({ keepAlive: true });
exports.defaultTimeout = 10000;
exports.userAgent = `google-maps-services-node-${index_1.version}`;
exports.acceptEncoding = "gzip";
exports.X_GOOG_MAPS_EXPERIENCE_ID = "X-GOOG-MAPS-EXPERIENCE-ID";
const defaultConfig = {
    timeout: exports.defaultTimeout,
    httpsAgent: exports.defaultHttpsAgent,
    adapter: adapter_1.customAdapter,
    headers: {
        "User-Agent": exports.userAgent,
        "Accept-Encoding": exports.acceptEncoding,
    },
};
exports.defaultAxiosInstance = axios_1.default.create(defaultConfig);
rax.attach(exports.defaultAxiosInstance);
/**
 * Client is a light wrapper around API methods providing shared configuration for Axios
 * settings such as retry logic using the default retry-axios settings and gzip encoding.
 *
 * ### Instantiate with defaults
 * ```
 * const client = Client()
 * ```
 *
 * ### Instantiate with config
 * ```
 * const client = Client({config})
 * ```
 *
 * ### Instantiate with axiosInstance **Advanced**
 * ```
 * const axiosInstance = axios.create(config)
 * const client = Client({axiosInstance})
 * ```
 */
class Client {
    constructor({ axiosInstance, config, experienceId } = {}) {
        if (axiosInstance && config) {
            throw new Error("Provide one of axiosInstance or config.");
        }
        if (axiosInstance) {
            this.axiosInstance = axiosInstance;
            this.axiosInstance.defaults.headers = Object.assign(Object.assign({}, defaultConfig.headers), this.axiosInstance.defaults.headers);
        }
        else if (config) {
            config = Object.assign(Object.assign({}, defaultConfig), config);
            config.headers = Object.assign(Object.assign({}, defaultConfig.headers), (config.headers || {}));
            this.axiosInstance = axios_1.default.create(config);
            rax.attach(this.axiosInstance);
        }
        else {
            this.axiosInstance = exports.defaultAxiosInstance;
        }
        if (experienceId) {
            this.setExperienceId(...experienceId);
        }
    }
    setExperienceId(...ids) {
        this.experienceId = ids;
        this.axiosInstance.defaults.headers[exports.X_GOOG_MAPS_EXPERIENCE_ID] = ids.join(",");
    }
    clearExperienceId() {
        this.experienceId = null;
        this.clearExperienceIdHeader();
    }
    clearExperienceIdHeader() {
        delete this.axiosInstance.defaults.headers[exports.X_GOOG_MAPS_EXPERIENCE_ID];
    }
    getExperienceId() {
        return this.experienceId;
    }
    directions(request) {
        return directions_1.directions(request, this.axiosInstance);
    }
    distancematrix(request) {
        return distance_1.distancematrix(request, this.axiosInstance);
    }
    elevation(request) {
        return elevation_1.elevation(request, this.axiosInstance);
    }
    timezone(request) {
        return timezone_1.timezone(request, this.axiosInstance);
    }
    geolocate(request) {
        return geolocate_1.geolocate(request, this.axiosInstance);
    }
    geocode(request) {
        return geocode_1.geocode(request, this.axiosInstance);
    }
    reverseGeocode(request) {
        return reversegeocode_1.reverseGeocode(request, this.axiosInstance);
    }
    placeAutocomplete(request) {
        return autocomplete_1.placeAutocomplete(request, this.axiosInstance);
    }
    placeDetails(request) {
        return details_1.placeDetails(request, this.axiosInstance);
    }
    findPlaceFromText(request) {
        return findplacefromtext_1.findPlaceFromText(request, this.axiosInstance);
    }
    placePhoto(request) {
        return photo_1.placePhoto(request, this.axiosInstance);
    }
    placesNearby(request) {
        return placesnearby_1.placesNearby(request, this.axiosInstance);
    }
    placeQueryAutocomplete(request) {
        return queryautocomplete_1.placeQueryAutocomplete(request, this.axiosInstance);
    }
    textSearch(request) {
        return textsearch_1.textSearch(request, this.axiosInstance);
    }
    nearestRoads(request) {
        return nearestroads_1.nearestRoads(request, this.axiosInstance);
    }
    snapToRoads(request) {
        return snaptoroads_1.snapToRoads(request, this.axiosInstance);
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map