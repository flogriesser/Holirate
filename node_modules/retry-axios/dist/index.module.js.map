{"version":3,"file":"index.module.js","sources":["../src/index.ts"],"sourcesContent":["import axios, {\n  AxiosError,\n  AxiosInstance,\n  AxiosRequestConfig,\n  AxiosResponse,\n} from 'axios';\n\n/**\n * Configuration for the Axios `request` method.\n */\nexport interface RetryConfig {\n  /**\n   * The number of times to retry the request.  Defaults to 3.\n   */\n  retry?: number;\n\n  /**\n   * The number of retries already attempted.\n   */\n  currentRetryAttempt?: number;\n\n  /**\n   * The amount of time to initially delay the retry.  Defaults to 100.\n   */\n  retryDelay?: number;\n\n  /**\n   * The instance of the axios object to which the interceptor is attached.\n   */\n  instance?: AxiosInstance;\n\n  /**\n   * The HTTP Methods that will be automatically retried.\n   * Defaults to ['GET','PUT','HEAD','OPTIONS','DELETE']\n   */\n  httpMethodsToRetry?: string[];\n\n  /**\n   * The HTTP response status codes that will automatically be retried.\n   * Defaults to: [[100, 199], [429, 429], [500, 599]]\n   */\n  statusCodesToRetry?: number[][];\n\n  /**\n   * Function to invoke when a retry attempt is made.\n   */\n  onRetryAttempt?: (err: AxiosError) => void;\n\n  /**\n   * Function to invoke which determines if you should retry\n   */\n  shouldRetry?: (err: AxiosError) => boolean;\n\n  /**\n   * When there is no response, the number of retries to attempt. Defaults to 2.\n   */\n  noResponseRetries?: number;\n\n  /**\n   * Backoff Type; 'linear', 'static' or 'exponential'.\n   */\n  backoffType?: 'linear' | 'static' | 'exponential';\n}\n\nexport type RaxConfig = {\n  raxConfig: RetryConfig;\n} & AxiosRequestConfig;\n\n/**\n * Attach the interceptor to the Axios instance.\n * @param instance The optional Axios instance on which to attach the\n * interceptor.\n * @returns The id of the interceptor attached to the axios instance.\n */\nexport function attach(instance?: AxiosInstance) {\n  instance = instance || axios;\n  return instance.interceptors.response.use(onFulfilled, onError);\n}\n\n/**\n * Eject the Axios interceptor that is providing retry capabilities.\n * @param interceptorId The interceptorId provided in the config.\n * @param instance The axios instance using this interceptor.\n */\nexport function detach(interceptorId: number, instance?: AxiosInstance) {\n  instance = instance || axios;\n  instance.interceptors.response.eject(interceptorId);\n}\n\nfunction onFulfilled(res: AxiosResponse) {\n  return res;\n}\n\n/**\n * Some versions of axios are converting arrays into objects during retries.\n * This will attempt to convert an object with the following structure into\n * an array, where the keys correspond to the indices:\n * {\n *   0: {\n *     // some property\n *   },\n *   1: {\n *     // another\n *   }\n * }\n * @param obj The object that (may) have integers that correspond to an index\n * @returns An array with the pucked values\n */\nfunction normalizeArray<T>(obj?: T[]): T[] | undefined {\n  const arr: T[] = [];\n  if (!obj) {\n    return undefined;\n  }\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n  if (typeof obj === 'object') {\n    Object.keys(obj).forEach(key => {\n      if (typeof key === 'number') {\n        arr[key] = obj[key];\n      }\n    });\n  }\n  return arr;\n}\n\nfunction onError(err: AxiosError) {\n  if (axios.isCancel(err)) {\n    return Promise.reject(err);\n  }\n\n  const config = getConfig(err) || {};\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n  config.retry = typeof config.retry === 'number' ? config.retry : 3;\n  config.retryDelay =\n    typeof config.retryDelay === 'number' ? config.retryDelay : 100;\n  config.instance = config.instance || axios;\n  config.backoffType = config.backoffType || 'exponential';\n  config.httpMethodsToRetry = normalizeArray(config.httpMethodsToRetry) || [\n    'GET',\n    'HEAD',\n    'PUT',\n    'OPTIONS',\n    'DELETE',\n  ];\n  config.noResponseRetries =\n    typeof config.noResponseRetries === 'number' ? config.noResponseRetries : 2;\n\n  // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n  const retryRanges = [\n    // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes\n    // 1xx - Retry (Informational, request still processing)\n    // 2xx - Do not retry (Success)\n    // 3xx - Do not retry (Redirect)\n    // 4xx - Do not retry (Client errors)\n    // 429 - Retry (\"Too Many Requests\")\n    // 5xx - Retry (Server errors)\n    [100, 199],\n    [429, 429],\n    [500, 599],\n  ];\n  config.statusCodesToRetry =\n    normalizeArray(config.statusCodesToRetry) || retryRanges;\n\n  // Put the config back into the err\n  err.config = err.config || {}; // allow for wider range of errors\n  (err.config as RaxConfig).raxConfig = {...config};\n\n  // Determine if we should retry the request\n  const shouldRetryFn = config.shouldRetry || shouldRetryRequest;\n  if (!shouldRetryFn(err)) {\n    return Promise.reject(err);\n  }\n\n  // Create a promise that invokes the retry after the backOffDelay\n  const onBackoffPromise = new Promise(resolve => {\n    // Calculate time to wait with exponential backoff.\n    // Formula: (2^c - 1 / 2) * 1000\n    let delay: number;\n    if (config.backoffType === 'linear') {\n      delay = config.currentRetryAttempt! * 1000;\n    } else if (config.backoffType === 'static') {\n      delay = config.retryDelay!;\n    } else {\n      delay = ((Math.pow(2, config.currentRetryAttempt!) - 1) / 2) * 1000;\n    }\n\n    // We're going to retry!  Incremenent the counter.\n    (err.config as RaxConfig).raxConfig!.currentRetryAttempt! += 1;\n    setTimeout(resolve, delay);\n  });\n\n  // Notify the user if they added an `onRetryAttempt` handler\n  const onRetryAttemptPromise = config.onRetryAttempt\n    ? Promise.resolve(config.onRetryAttempt(err))\n    : Promise.resolve();\n\n  // Return the promise in which recalls axios to retry the request\n  return Promise.resolve()\n    .then(() => onBackoffPromise)\n    .then(() => onRetryAttemptPromise)\n    .then(() => config.instance!.request(err.config));\n}\n\n/**\n * Determine based on config if we should retry the request.\n * @param err The AxiosError passed to the interceptor.\n */\nexport function shouldRetryRequest(err: AxiosError) {\n  const config = (err.config as RaxConfig).raxConfig;\n\n  // If there's no config, or retries are disabled, return.\n  if (!config || config.retry === 0) {\n    return false;\n  }\n\n  // Check if this error has no response (ETIMEDOUT, ENOTFOUND, etc)\n  if (\n    !err.response &&\n    (config.currentRetryAttempt || 0) >= config.noResponseRetries!\n  ) {\n    return false;\n  }\n\n  // Only retry with configured HttpMethods.\n  if (\n    !err.config.method ||\n    config.httpMethodsToRetry!.indexOf(err.config.method.toUpperCase()) < 0\n  ) {\n    return false;\n  }\n\n  // If this wasn't in the list of status codes where we want\n  // to automatically retry, return.\n  if (err.response && err.response.status) {\n    let isInRange = false;\n    for (const [min, max] of config.statusCodesToRetry!) {\n      const status = err.response.status;\n      if (status >= min && status <= max) {\n        isInRange = true;\n        break;\n      }\n    }\n    if (!isInRange) {\n      return false;\n    }\n  }\n\n  // If we are out of retry attempts, return\n  config.currentRetryAttempt = config.currentRetryAttempt || 0;\n  if (config.currentRetryAttempt >= config.retry!) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Acquire the raxConfig object from an AxiosError if available.\n * @param err The Axios error with a config object.\n */\nexport function getConfig(err: AxiosError) {\n  if (err && err.config) {\n    return (err.config as RaxConfig).raxConfig;\n  }\n  return;\n}\n\n// Include this so `config.raxConfig` works easily.\n// See https://github.com/JustinBeckwith/retry-axios/issues/64.\ndeclare module 'axios' {\n  export interface AxiosRequestConfig {\n    raxConfig?: RetryConfig;\n  }\n}\n"],"names":["attach","instance","axios","interceptors","response","use","onFulfilled","onError","detach","interceptorId","eject","res","normalizeArray","obj","arr","Array","isArray","Object","keys","forEach","key","err","isCancel","Promise","reject","config","getConfig","currentRetryAttempt","retry","retryDelay","backoffType","httpMethodsToRetry","noResponseRetries","statusCodesToRetry","raxConfig","shouldRetry","shouldRetryRequest","onBackoffPromise","resolve","delay","Math","pow","setTimeout","onRetryAttemptPromise","onRetryAttempt","then","request","method","indexOf","toUpperCase","status","isInRange","const"],"mappings":"8BA0EgBA,EAAOC,UACrBA,EAAWA,GAAYC,GACPC,aAAaC,SAASC,IAAIC,EAAaC,YAQzCC,EAAOC,EAAuBR,IAC5CA,EAAWA,GAAYC,GACdC,aAAaC,SAASM,MAAMD,GAGvC,SAASH,EAAYK,UACZA,EAkBT,SAASC,EAAkBC,OACnBC,EAAW,MACZD,SAGDE,MAAMC,QAAQH,GACTA,GAEU,iBAARA,GACTI,OAAOC,KAAKL,GAAKM,iBAAQC,GACJ,iBAARA,IACTN,EAAIM,GAAOP,EAAIO,MAIdN,GAGT,SAASP,EAAQc,MACXnB,EAAMoB,SAASD,UACVE,QAAQC,OAAOH,OAGlBI,EAASC,EAAUL,IAAQ,MACjCI,EAAOE,oBAAsBF,EAAOE,qBAAuB,EAC3DF,EAAOG,MAAgC,iBAAjBH,EAAOG,MAAqBH,EAAOG,MAAQ,EACjEH,EAAOI,WACwB,iBAAtBJ,EAAOI,WAA0BJ,EAAOI,WAAa,IAC9DJ,EAAOxB,SAAWwB,EAAOxB,UAAYC,EACrCuB,EAAOK,YAAcL,EAAOK,aAAe,cAC3CL,EAAOM,mBAAqBnB,EAAea,EAAOM,qBAAuB,CACvE,MACA,OACA,MACA,UACA,UAEFN,EAAOO,kBAC+B,iBAA7BP,EAAOO,kBAAiCP,EAAOO,kBAAoB,EAgB5EP,EAAOQ,mBACLrB,EAAea,EAAOQ,qBAbJ,EAQjB,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,MAMRZ,EAAII,OAASJ,EAAII,QAAU,GAC1BJ,EAAII,OAAqBS,UAAYjB,iBAAIQ,KAGpBA,EAAOU,aAAeC,GACzBf,UACVE,QAAQC,OAAOH,OAIlBgB,EAAmB,IAAId,iBAAQe,OAG/BC,EAEFA,EADyB,WAAvBd,EAAOK,YAC6B,IAA9BL,EAAOE,oBACiB,WAAvBF,EAAOK,YACRL,EAAOI,YAELW,KAAKC,IAAI,EAAGhB,EAAOE,qBAAwB,GAAK,EAAK,IAIhEN,EAAII,OAAqBS,UAAWP,qBAAwB,EAC7De,WAAWJ,EAASC,KAIhBI,EAAwBlB,EAAOmB,eACjCrB,QAAQe,QAAQb,EAAOmB,eAAevB,IACtCE,QAAQe,iBAGLf,QAAQe,UACZO,uBAAWR,IACXQ,uBAAWF,IACXE,uBAAWpB,EAAOxB,SAAU6C,QAAQzB,EAAII,mBAO7BW,EAAmBf,OAC3BI,EAAUJ,EAAII,OAAqBS,cAGpCT,GAA2B,IAAjBA,EAAOG,aACb,MAKNP,EAAIjB,WACJqB,EAAOE,qBAAuB,IAAMF,EAAOO,yBAErC,MAKNX,EAAII,OAAOsB,QACZtB,EAAOM,mBAAoBiB,QAAQ3B,EAAII,OAAOsB,OAAOE,eAAiB,SAE/D,KAKL5B,EAAIjB,UAAYiB,EAAIjB,SAAS8C,OAAQ,SACnCC,GAAY,QACS1B,EAAOQ,mCAAqB,CAAhDmB,WACGF,EAAS7B,EAAIjB,SAAS8C,UACxBA,SAAiBA,QAAe,CAClCC,GAAY,aAIXA,SACI,SAKX1B,EAAOE,oBAAsBF,EAAOE,qBAAuB,IACvDF,EAAOE,qBAAuBF,EAAOG,gBAW3BF,EAAUL,MACpBA,GAAOA,EAAII,cACLJ,EAAII,OAAqBS"}